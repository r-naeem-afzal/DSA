[
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "MinHeap",
        "importPath": "heaps.min_heap",
        "description": "heaps.min_heap",
        "isExtraImport": true,
        "detail": "heaps.min_heap",
        "documentation": {}
    },
    {
        "label": "CircularLinkedList",
        "importPath": "data_structures.linked_lists.circular_linked_list",
        "description": "data_structures.linked_lists.circular_linked_list",
        "isExtraImport": true,
        "detail": "data_structures.linked_lists.circular_linked_list",
        "documentation": {}
    },
    {
        "label": "DoublyCircularLinkedList",
        "importPath": "linked_lists.doubly_circular_linked_list",
        "description": "linked_lists.doubly_circular_linked_list",
        "isExtraImport": true,
        "detail": "linked_lists.doubly_circular_linked_list",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "data_structures.linked_lists.node",
        "description": "data_structures.linked_lists.node",
        "isExtraImport": true,
        "detail": "data_structures.linked_lists.node",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "data_structures.linked_lists.node",
        "description": "data_structures.linked_lists.node",
        "isExtraImport": true,
        "detail": "data_structures.linked_lists.node",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "data_structures.linked_lists.node",
        "description": "data_structures.linked_lists.node",
        "isExtraImport": true,
        "detail": "data_structures.linked_lists.node",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "node",
        "description": "node",
        "isExtraImport": true,
        "detail": "node",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "node",
        "description": "node",
        "isExtraImport": true,
        "detail": "node",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queues.queue",
        "description": "queues.queue",
        "isExtraImport": true,
        "detail": "queues.queue",
        "documentation": {}
    },
    {
        "label": "Stack",
        "importPath": "stacks.stack",
        "description": "stacks.stack",
        "isExtraImport": true,
        "detail": "stacks.stack",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Factory",
        "importPath": "factory.factory",
        "description": "factory.factory",
        "isExtraImport": true,
        "detail": "factory.factory",
        "documentation": {}
    },
    {
        "label": "Publisher",
        "importPath": "observer.observer",
        "description": "observer.observer",
        "isExtraImport": true,
        "detail": "observer.observer",
        "documentation": {}
    },
    {
        "label": "Subscriber",
        "importPath": "observer.observer",
        "description": "observer.observer",
        "isExtraImport": true,
        "detail": "observer.observer",
        "documentation": {}
    },
    {
        "label": "Singleton",
        "importPath": "singleton.singleton",
        "description": "singleton.singleton",
        "isExtraImport": true,
        "detail": "singleton.singleton",
        "documentation": {}
    },
    {
        "label": "Strategy",
        "importPath": "strategy.strategy",
        "description": "strategy.strategy",
        "isExtraImport": true,
        "detail": "strategy.strategy",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "GroceryListManager",
        "kind": 6,
        "importPath": "data_structures.arrays.examples.grocery_list",
        "description": "data_structures.arrays.examples.grocery_list",
        "peekOfCode": "class GroceryListManager:\n    def __init__(self):\n        self.grocery_list = []\n    def display_menu(self):\n        print(\"\\nGrocery List Manager\")\n        print(\"1. Add Item\")\n        print(\"2. Remove Item\")\n        print(\"3. View List\")\n        print(\"4. Sort List\")\n        print(\"5. Reverse List\")",
        "detail": "data_structures.arrays.examples.grocery_list",
        "documentation": {}
    },
    {
        "label": "empty_array",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "empty_array = []\n# * Create a filled arrau\nfilled_array = [\"A\", \"B\", \"C\"]\nprint(\"\\n\")\nprint(\"Accessing Elements\")\nprint(\"\\n\")\n# ? Method: Add\n# * Add an element to the end of the array\nempty_array.append(\"A\")\nprint(f\"Add an element to the end of the array: {empty_array}\")  # Output: ['A']",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "filled_array",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "filled_array = [\"A\", \"B\", \"C\"]\nprint(\"\\n\")\nprint(\"Accessing Elements\")\nprint(\"\\n\")\n# ? Method: Add\n# * Add an element to the end of the array\nempty_array.append(\"A\")\nprint(f\"Add an element to the end of the array: {empty_array}\")  # Output: ['A']\n# ? Method: Insert\n# * Insert an element at a specific index",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "numbers = [i for i in range(10)]\nprint(\n    f\"Create a list of numbers from 0 to 9: {numbers}\"\n)  # Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n# * Create a list of even numbers from 0 to 9\neven_numbers = [i for i in range(10) if i % 2 == 0]\nprint(\n    f\"Create a list of even numbers from 0 to 9: {even_numbers}\"\n)  # Output: [0, 2, 4, 6, 8]\n# * Create a list of squares from 0 to 9",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "even_numbers",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "even_numbers = [i for i in range(10) if i % 2 == 0]\nprint(\n    f\"Create a list of even numbers from 0 to 9: {even_numbers}\"\n)  # Output: [0, 2, 4, 6, 8]\n# * Create a list of squares from 0 to 9\nsquares = [i**2 for i in range(10)]\nprint(\n    f\"Create a list of squares from 0 to 9: {squares}\"\n)  # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n# * Create a list of squares from 0 to 9, but only if the number is even",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "squares",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "squares = [i**2 for i in range(10)]\nprint(\n    f\"Create a list of squares from 0 to 9: {squares}\"\n)  # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n# * Create a list of squares from 0 to 9, but only if the number is even\neven_squares = [i**2 for i in range(10) if i % 2 == 0]\nprint(\n    f\"Create a list of squares from 0 to 9, but only if the number is even: {even_squares}\"\n)  # Output: [0, 4, 16, 36, 64]\n# * Create a list of squares from 0 to 9, but only if the number is even, and the number is greater than 4",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "even_squares",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "even_squares = [i**2 for i in range(10) if i % 2 == 0]\nprint(\n    f\"Create a list of squares from 0 to 9, but only if the number is even: {even_squares}\"\n)  # Output: [0, 4, 16, 36, 64]\n# * Create a list of squares from 0 to 9, but only if the number is even, and the number is greater than 4\neven_squares_greater_than_4 = [i**2 for i in range(10) if i % 2 == 0 and i > 4]\nprint(\n    f\"Create a list of squares from 0 to 9, but only if the number is even, and the number is greater than 4: {even_squares_greater_than_4}\"\n)  # Output: [16, 36, 64]\nprint(\"\\n\")",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "even_squares_greater_than_4",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "even_squares_greater_than_4 = [i**2 for i in range(10) if i % 2 == 0 and i > 4]\nprint(\n    f\"Create a list of squares from 0 to 9, but only if the number is even, and the number is greater than 4: {even_squares_greater_than_4}\"\n)  # Output: [16, 36, 64]\nprint(\"\\n\")\nprint(\"Slicing Arrays\")\nprint(\"\\n\")\n#! Slicing Arrays\n# * Create an array of numbers from 0 to 9\nnumbers = [i for i in range(10)]",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "numbers = [i for i in range(10)]\nprint(\n    f\"Create an array of numbers from 0 to 9: {numbers}\"\n)  # Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n# * Get the first element\nfirst_element = numbers[0]\nprint(f\"Get the first element: {first_element}\")  # Output: 0\n# * Get the last element\nlast_element = numbers[-1]\nprint(f\"Get the last element: {last_element}\")  # Output: 9",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "first_element",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "first_element = numbers[0]\nprint(f\"Get the first element: {first_element}\")  # Output: 0\n# * Get the last element\nlast_element = numbers[-1]\nprint(f\"Get the last element: {last_element}\")  # Output: 9\n# * Get the first 3 elements\nfirst_3_elements = numbers[:3]\nprint(f\"Get the first 3 elements: {first_3_elements}\")  # Output: [0, 1, 2]\n# * Get the last 3 elements\nlast_3_elements = numbers[-3:]",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "last_element",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "last_element = numbers[-1]\nprint(f\"Get the last element: {last_element}\")  # Output: 9\n# * Get the first 3 elements\nfirst_3_elements = numbers[:3]\nprint(f\"Get the first 3 elements: {first_3_elements}\")  # Output: [0, 1, 2]\n# * Get the last 3 elements\nlast_3_elements = numbers[-3:]\nprint(f\"Get the last 3 elements: {last_3_elements}\")  # Output: [7, 8, 9]\n# * Get the elements from index 2 to 5\nelements_2_to_5 = numbers[2:6]",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "first_3_elements",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "first_3_elements = numbers[:3]\nprint(f\"Get the first 3 elements: {first_3_elements}\")  # Output: [0, 1, 2]\n# * Get the last 3 elements\nlast_3_elements = numbers[-3:]\nprint(f\"Get the last 3 elements: {last_3_elements}\")  # Output: [7, 8, 9]\n# * Get the elements from index 2 to 5\nelements_2_to_5 = numbers[2:6]\nprint(f\"Get the elements from index 2 to 5: {elements_2_to_5}\")  # Output: [2, 3, 4, 5]\n# * Get the elements from index 2 to 5, but only every other element\nelements_2_to_5_every_other = numbers[2:6:2]",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "last_3_elements",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "last_3_elements = numbers[-3:]\nprint(f\"Get the last 3 elements: {last_3_elements}\")  # Output: [7, 8, 9]\n# * Get the elements from index 2 to 5\nelements_2_to_5 = numbers[2:6]\nprint(f\"Get the elements from index 2 to 5: {elements_2_to_5}\")  # Output: [2, 3, 4, 5]\n# * Get the elements from index 2 to 5, but only every other element\nelements_2_to_5_every_other = numbers[2:6:2]\nprint(\n    f\"Get the elements from index 2 to 5, but only every other element: {elements_2_to_5_every_other}\"\n)  # Output: [2, 4]",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "elements_2_to_5",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "elements_2_to_5 = numbers[2:6]\nprint(f\"Get the elements from index 2 to 5: {elements_2_to_5}\")  # Output: [2, 3, 4, 5]\n# * Get the elements from index 2 to 5, but only every other element\nelements_2_to_5_every_other = numbers[2:6:2]\nprint(\n    f\"Get the elements from index 2 to 5, but only every other element: {elements_2_to_5_every_other}\"\n)  # Output: [2, 4]\n# * Reverse the array\nreversed_array = numbers[::-1]\nprint(f\"Reverse the array: {reversed_array}\")  # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "elements_2_to_5_every_other",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "elements_2_to_5_every_other = numbers[2:6:2]\nprint(\n    f\"Get the elements from index 2 to 5, but only every other element: {elements_2_to_5_every_other}\"\n)  # Output: [2, 4]\n# * Reverse the array\nreversed_array = numbers[::-1]\nprint(f\"Reverse the array: {reversed_array}\")  # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n# * Reverse the array, but only every other element\nreversed_array_every_other = numbers[::-2]\nprint(",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "reversed_array",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "reversed_array = numbers[::-1]\nprint(f\"Reverse the array: {reversed_array}\")  # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n# * Reverse the array, but only every other element\nreversed_array_every_other = numbers[::-2]\nprint(\n    f\"Reverse the array, but only every other element: {reversed_array_every_other}\"\n)  # Output: [9, 7, 5, 3, 1]\n# * Reverse the array, but only the first 5 elements\nreversed_array_first_5 = numbers[5::-1]\nprint(",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "reversed_array_every_other",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "reversed_array_every_other = numbers[::-2]\nprint(\n    f\"Reverse the array, but only every other element: {reversed_array_every_other}\"\n)  # Output: [9, 7, 5, 3, 1]\n# * Reverse the array, but only the first 5 elements\nreversed_array_first_5 = numbers[5::-1]\nprint(\n    f\"Reverse the array, but only the first 5 elements: {reversed_array_first_5}\"\n)  # Output: [5, 4, 3, 2, 1, 0]\n# * Reverse the array, but only the last 5 elements",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "reversed_array_first_5",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "reversed_array_first_5 = numbers[5::-1]\nprint(\n    f\"Reverse the array, but only the first 5 elements: {reversed_array_first_5}\"\n)  # Output: [5, 4, 3, 2, 1, 0]\n# * Reverse the array, but only the last 5 elements\nreversed_array_last_5 = numbers[:-6:-1]\nprint(\n    f\"Reverse the array, but only the last 5 elements: {reversed_array_last_5}\"\n)  # Output: [9, 8, 7, 6, 5]\n# * Reverse the array, but only the first 5 elements, and only every other element",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "reversed_array_last_5",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "reversed_array_last_5 = numbers[:-6:-1]\nprint(\n    f\"Reverse the array, but only the last 5 elements: {reversed_array_last_5}\"\n)  # Output: [9, 8, 7, 6, 5]\n# * Reverse the array, but only the first 5 elements, and only every other element\nreversed_array_first_5_every_other = numbers[5::-2]\nprint(\n    f\"Reverse the array, but only the first 5 elements, and only every other element: {reversed_array_first_5_every_other}\"\n)  # Output: [5, 3, 1]\n# * Reverse the array, but only the last 5 elements, and only every other element",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "reversed_array_first_5_every_other",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "reversed_array_first_5_every_other = numbers[5::-2]\nprint(\n    f\"Reverse the array, but only the first 5 elements, and only every other element: {reversed_array_first_5_every_other}\"\n)  # Output: [5, 3, 1]\n# * Reverse the array, but only the last 5 elements, and only every other element\nreversed_array_last_5_every_other = numbers[:-6:-2]\nprint(\n    f\"Reverse the array, but only the last 5 elements, and only every other element: {reversed_array_last_5_every_other}\"\n)  # Output: [9, 7, 5]",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "reversed_array_last_5_every_other",
        "kind": 5,
        "importPath": "data_structures.arrays.arrays",
        "description": "data_structures.arrays.arrays",
        "peekOfCode": "reversed_array_last_5_every_other = numbers[:-6:-2]\nprint(\n    f\"Reverse the array, but only the last 5 elements, and only every other element: {reversed_array_last_5_every_other}\"\n)  # Output: [9, 7, 5]",
        "detail": "data_structures.arrays.arrays",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "data_structures.graphs.graph",
        "description": "data_structures.graphs.graph",
        "peekOfCode": "class Graph:\n    \"\"\"\n    A class to represent an undirected graph using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a vertex in the graph. In this implementation, a dictionary is used to store the adjacency list. The keys of the dictionary represent the vertices, and the values represent the neighbors of the corresponding vertex.\n    Attributes:\n    - graph: A dictionary to store the adjacency list of the graph.\n    Methods:\n    - add_edge(u: int, v: int) -> None: Adds an edge between vertices u and v.\n    - remove_edge(u: int, v: int) -> None: Removes the edge between vertices u and v.\n    - add_vertex(v: int) -> None: Adds a new vertex to the graph.\n    - remove_vertex(v: int) -> None: Removes a vertex from the graph.",
        "detail": "data_structures.graphs.graph",
        "documentation": {}
    },
    {
        "label": "TaskScheduler",
        "kind": 6,
        "importPath": "data_structures.heaps.examples.task_scheduler",
        "description": "data_structures.heaps.examples.task_scheduler",
        "peekOfCode": "class TaskScheduler:\n    def __init__(self) -> None:\n        self.tasks = MinHeap()\n    def add_task(self, task: str, priority: int) -> None:\n        self.tasks.insert((priority, task))\n        print(f'Task \"{task}\" added to the scheduler.')\n    def get_next_task(self) -> None:\n        task = self.tasks.extract_min()\n        if task:\n            print(f'Next task: \"{task[1]}\"')",
        "detail": "data_structures.heaps.examples.task_scheduler",
        "documentation": {}
    },
    {
        "label": "MinHeap",
        "kind": 6,
        "importPath": "data_structures.heaps.min_heap",
        "description": "data_structures.heaps.min_heap",
        "peekOfCode": "class MinHeap:\n    \"\"\"\n    A MinHeap is a complete binary tree where each node is smaller than its children. The root node is the smallest element in the heap. The two main operations are insert and extract_min. The time complexity of both operations is O(log n).\n    Attributes:\n    - heap: A list to store the elements in the heap.\n    Methods:\n    - get_parent_index(index: int) -> int: Returns the index of the parent node of the node at the given index.\n    - get_left_child_index(index: int) -> int: Returns the index of the left child of the node at the given index.\n    - get_right_child_index(index: int) -> int: Returns the index of the right child of the node at the given index.\n    - has_parent(index: int) -> bool: Returns True if the node at the given index has a parent, False otherwise.",
        "detail": "data_structures.heaps.min_heap",
        "documentation": {}
    },
    {
        "label": "MusicPlaylist",
        "kind": 6,
        "importPath": "data_structures.linked_lists.examples.circular_linked_playlist",
        "description": "data_structures.linked_lists.examples.circular_linked_playlist",
        "peekOfCode": "class MusicPlaylist:\n    def __init__(self):\n        self.playlist = CircularLinkedList()\n    def add_song(self, song_name):\n        self.playlist.append(song_name)\n        print(f'Song \"{song_name}\" added to the playlist.')\n    def remove_song(self, song_name):\n        self.playlist.delete_node(song_name)\n        print(f'Song \"{song_name}\" removed from the playlist.')\n    def show_playlist(self):",
        "detail": "data_structures.linked_lists.examples.circular_linked_playlist",
        "documentation": {}
    },
    {
        "label": "Carousel",
        "kind": 6,
        "importPath": "data_structures.linked_lists.examples.doubly_linked_list_carousel",
        "description": "data_structures.linked_lists.examples.doubly_linked_list_carousel",
        "peekOfCode": "class Carousel:\n    def __init__(self) -> None:\n        self.images = DoublyCircularLinkedList()\n    def add_image(self, image_name: str) -> None:\n        self.images.append(image_name)\n        print(f'Image \"{image_name}\" added to the carousel.')\n    def remove_image(self, image_name: str) -> None:\n        self.images.delete_node(image_name)\n        print(f'Image \"{image_name}\" removed from the carousel.')\n    def show_images(self) -> None:",
        "detail": "data_structures.linked_lists.examples.doubly_linked_list_carousel",
        "documentation": {}
    },
    {
        "label": "SongNode",
        "kind": 6,
        "importPath": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "description": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "peekOfCode": "class SongNode:\n    def __init__(self, song, next=None):\n        self.song = song\n        self.next = next\n        self.prev = None\nclass Playlist:\n    def __init__(self) -> None:\n        self.head: SongNode | None = None\n    def is_empty(self) -> bool:\n        return self.head is None",
        "detail": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "documentation": {}
    },
    {
        "label": "Playlist",
        "kind": 6,
        "importPath": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "description": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "peekOfCode": "class Playlist:\n    def __init__(self) -> None:\n        self.head: SongNode | None = None\n    def is_empty(self) -> bool:\n        return self.head is None\n    def add_song(self, song: str) -> None:\n        new_song = SongNode(song)\n        if self.is_empty():\n            self.head = new_song\n            return",
        "detail": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "documentation": {}
    },
    {
        "label": "SONG_4",
        "kind": 5,
        "importPath": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "description": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "peekOfCode": "SONG_4 = \"Song 4\"\nif __name__ == \"__main__\":\n    playlist = Playlist()\n    playlist.add_song(\"Song 1\")\n    playlist.add_song(\"Song 2\")\n    playlist.add_song(\"Song 3\")\n    playlist.add_song(SONG_4)\n    playlist.add_song(\"Song 5\")\n    playlist.display_songs()\n    print()",
        "detail": "data_structures.linked_lists.examples.doubly_linked_playlist",
        "documentation": {}
    },
    {
        "label": "CircularLinkedList",
        "kind": 6,
        "importPath": "data_structures.linked_lists.circular_linked_list",
        "description": "data_structures.linked_lists.circular_linked_list",
        "peekOfCode": "class CircularLinkedList:\n    \"\"\"\n    A circular linked list is a linked list where all nodes are connected to form a circle. Each node has a reference to the next node in the sequence. The last node points back to the first node. The list can be traversed in both directions.\n    Operations:\n    - is_empty: Check if the list is empty.\n    - append: Add an item to the end of the list.\n    - prepend: Add an item to the beginning of the list.\n    - insert: Add an item at a specific index in the list.\n    - delete_node: Remove an item from the list.\n    - display: Display the items in the list.",
        "detail": "data_structures.linked_lists.circular_linked_list",
        "documentation": {}
    },
    {
        "label": "DoublyCircularLinkedList",
        "kind": 6,
        "importPath": "data_structures.linked_lists.doubly_circular_linked_list",
        "description": "data_structures.linked_lists.doubly_circular_linked_list",
        "peekOfCode": "class DoublyCircularLinkedList:\n    \"\"\"\n    A doubly circular linked list is a linear data structure that consists of a sequence of elements. Each element points to the next element and the previous element. The last element points to the first element, forming a circle. The first element points to the last element. The list can be traversed in both directions.\n    Operations:\n    - is_empty: Check if the list is empty.\n    - append: Add an item to the end of the list.\n    - prepend: Add an item to the beginning of the list.\n    - insert_after: Add an item after a specific item in the list.\n    - delete_node: Remove an item from the list.\n    - display: Display the items in the list.",
        "detail": "data_structures.linked_lists.doubly_circular_linked_list",
        "documentation": {}
    },
    {
        "label": "DoublyLinkedList",
        "kind": 6,
        "importPath": "data_structures.linked_lists.doubly_linked_list",
        "description": "data_structures.linked_lists.doubly_linked_list",
        "peekOfCode": "class DoublyLinkedList:\n    \"\"\"\n    A doubly linked list is a list that consists of a sequence of elements in which every element has a link to its previous element and next element.\n    Operations:\n    - is_empty: Check if the list is empty.\n    - append: Add a new node to the end of the list.\n    - prepend: Add a new node to the beginning of the list.\n    - insert: Add a new node at a specific index.\n    - remove: Remove a node at a specific index.\n    Applications:",
        "detail": "data_structures.linked_lists.doubly_linked_list",
        "documentation": {}
    },
    {
        "label": "index_error_message",
        "kind": 5,
        "importPath": "data_structures.linked_lists.doubly_linked_list",
        "description": "data_structures.linked_lists.doubly_linked_list",
        "peekOfCode": "index_error_message = \"Index out of range\"\nclass DoublyLinkedList:\n    \"\"\"\n    A doubly linked list is a list that consists of a sequence of elements in which every element has a link to its previous element and next element.\n    Operations:\n    - is_empty: Check if the list is empty.\n    - append: Add a new node to the end of the list.\n    - prepend: Add a new node to the beginning of the list.\n    - insert: Add a new node at a specific index.\n    - remove: Remove a node at a specific index.",
        "detail": "data_structures.linked_lists.doubly_linked_list",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "data_structures.linked_lists.node",
        "description": "data_structures.linked_lists.node",
        "peekOfCode": "class Node:\n    def __init__(self, data: Any) -> None:\n        self.data = data\n        self.next: Node | None = None\n        self.prev: Node | None = None",
        "detail": "data_structures.linked_lists.node",
        "documentation": {}
    },
    {
        "label": "SinglyLinkedList",
        "kind": 6,
        "importPath": "data_structures.linked_lists.singly_linked_list",
        "description": "data_structures.linked_lists.singly_linked_list",
        "peekOfCode": "class SinglyLinkedList:\n    \"\"\"\n    A singly linked list is a data structure that consists of a sequence of nodes. Each node contains an element and a reference to the next node in the sequence. The list can be traversed in one direction.\n    Operations:\n    - is_empty: Check if the list is empty.\n    - append: Add a new node to the end of the list.\n    - prepend: Add a new node to the beginning of the list.\n    - insert: Add a new node at a specific index in the list.\n    - remove: Remove the first node with the specified data.\n    - pop: Remove the node at a specific index in the list.",
        "detail": "data_structures.linked_lists.singly_linked_list",
        "documentation": {}
    },
    {
        "label": "StackLinkedList",
        "kind": 6,
        "importPath": "data_structures.linked_lists.stack_linked_list",
        "description": "data_structures.linked_lists.stack_linked_list",
        "peekOfCode": "class StackLinkedList:\n    \"\"\"\n    A stack is a linear data structure that follows the Last In First Out (LIFO) principle. The last element added to the stack is the first element to be removed. A stack can be implemented using an array or a linked list. In this implementation, a singly linked list is used.\n    Operations:\n    - push: Add an element to the top of the stack.\n    - pop: Remove and return the element at the top of the stack.\n    - peek: Get the element at the top of the stack without removing it.\n    - is_empty: Check if the stack is empty.\n    - display: Display the elements in the stack.\n    Applications:",
        "detail": "data_structures.linked_lists.stack_linked_list",
        "documentation": {}
    },
    {
        "label": "TicketingSystem",
        "kind": 6,
        "importPath": "data_structures.queues.examples.ticketing_system",
        "description": "data_structures.queues.examples.ticketing_system",
        "peekOfCode": "class TicketingSystem:\n    def __init__(self) -> None:\n        self.customers = Queue()\n    def new_customer(self, customer_name: str) -> None:\n        self.customers.enqueue(customer_name)\n        print(f'Customer \"{customer_name}\" added to the queue.')\n    def serve_customer(self) -> None:\n        customer = self.customers.dequeue()\n        if customer:\n            print(f'Customer \"{customer}\" served.')",
        "detail": "data_structures.queues.examples.ticketing_system",
        "documentation": {}
    },
    {
        "label": "CircularQueue",
        "kind": 6,
        "importPath": "data_structures.queues.circular_queue",
        "description": "data_structures.queues.circular_queue",
        "peekOfCode": "class CircularQueue:\n    \"\"\"\n    A circular queue is a data structure that uses a single, fixed-size array to store elements. It follows the FIFO (First In First Out) principle. When the rear of the queue reaches the end of the array, it wraps around to the beginning of the array. This allows the queue to use the space efficiently.\n    Operations:\n    - is_empty: Check if the queue is empty.\n    - is_full: Check if the queue is full.\n    - enqueue: Add an item to the rear of the queue.\n    - dequeue: Remove an item from the front of the queue.\n    - peek: Get the item at the front of the queue without removing it.\n    - display: Display the items in the queue.",
        "detail": "data_structures.queues.circular_queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "data_structures.queues.queue",
        "description": "data_structures.queues.queue",
        "peekOfCode": "class Queue:\n    \"\"\"\n    A queue is a linear data structure that follows the FIFO (First In First Out) principle. The first element added to the queue is the first element to be removed. A queue can be implemented using an array or a linked list. In this implementation, a list is used.\n    Operations:\n    - is_empty: Check if the queue is empty.\n    - enqueue: Add an item to the rear of the queue.\n    - dequeue: Remove an item from the front of the queue.\n    - peek: Get the item at the front of the queue without removing it.\n    - size: Get the number of items in the queue.\n    - display: Display the items in the queue.",
        "detail": "data_structures.queues.queue",
        "documentation": {}
    },
    {
        "label": "TextEditor",
        "kind": 6,
        "importPath": "data_structures.stacks.examples.text_editor_undo",
        "description": "data_structures.stacks.examples.text_editor_undo",
        "peekOfCode": "class TextEditor:\n    def __init__(self) -> None:\n        self.text = \"\"\n        self.undo_stack = Stack()\n    def write(self, text: str) -> None:\n        self.text += text\n        self.undo_stack.push(f\"Undo: Delete {len(text)} characters\")\n    def delete(self, num_characters: int) -> None:\n        if num_characters > len(self.text):\n            print(\"Cannot delete more characters than present in the text.\")",
        "detail": "data_structures.stacks.examples.text_editor_undo",
        "documentation": {}
    },
    {
        "label": "editor",
        "kind": 5,
        "importPath": "data_structures.stacks.examples.text_editor_undo",
        "description": "data_structures.stacks.examples.text_editor_undo",
        "peekOfCode": "editor = TextEditor()\neditor.write(\"Hello\")\neditor.write(\" World\")\neditor.display()  # Output: Current text: Hello World\neditor.delete(1)\neditor.display()  # Output: Current text: Hello Worl\neditor.undo()\neditor.display()  # Output: Current text: Hello World\neditor.undo()\neditor.display()  # Output: Current text: Hello",
        "detail": "data_structures.stacks.examples.text_editor_undo",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "data_structures.stacks.stack",
        "description": "data_structures.stacks.stack",
        "peekOfCode": "class Stack:\n    \"\"\"\n    A stack is a linear data structure that follows the Last In First Out (LIFO) principle. The last element added to the stack is the first element to be removed.\n    Operations:\n    - is_empty: Check if the stack is empty.\n    - push: Add an element to the top of the stack.\n    - pop: Remove and return the element at the top of the stack.\n    - peek: Get the element at the top of the stack without removing it.\n    - display: Display the elements in the stack.\n    Applications:",
        "detail": "data_structures.stacks.stack",
        "documentation": {}
    },
    {
        "label": "stack",
        "kind": 5,
        "importPath": "data_structures.stacks.stack",
        "description": "data_structures.stacks.stack",
        "peekOfCode": "stack = Stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\nstack.display()  # Output: Stack: [1, 2, 3]\nprint(\"Peek:\", stack.peek())  # Output: Peek: 3\nstack.pop()  # Output: Popped 3 from the stack.\nstack.display()  # Output: Stack: [1, 2]",
        "detail": "data_structures.stacks.stack",
        "documentation": {}
    },
    {
        "label": "Decorator",
        "kind": 6,
        "importPath": "design_patterns.decorator.decorator",
        "description": "design_patterns.decorator.decorator",
        "peekOfCode": "class Decorator:\n    def __init__(self, coffee: Union[\"Coffee\", \"Decorator\"]):\n        self._coffee = coffee\n    def cost(self) -> float:\n        return self._coffee.cost()\nclass MilkDecorator(Decorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.5\nclass SugarDecorator(Decorator):\n    def cost(self) -> float:",
        "detail": "design_patterns.decorator.decorator",
        "documentation": {}
    },
    {
        "label": "MilkDecorator",
        "kind": 6,
        "importPath": "design_patterns.decorator.decorator",
        "description": "design_patterns.decorator.decorator",
        "peekOfCode": "class MilkDecorator(Decorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.5\nclass SugarDecorator(Decorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.2\n# ------------------------------------- x ------------------------------------ #\nclass Coffee:\n    def cost(self) -> float:\n        return 2",
        "detail": "design_patterns.decorator.decorator",
        "documentation": {}
    },
    {
        "label": "SugarDecorator",
        "kind": 6,
        "importPath": "design_patterns.decorator.decorator",
        "description": "design_patterns.decorator.decorator",
        "peekOfCode": "class SugarDecorator(Decorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.2\n# ------------------------------------- x ------------------------------------ #\nclass Coffee:\n    def cost(self) -> float:\n        return 2\nif __name__ == \"__main__\":\n    coffee = Coffee()\n    print(f\"Cost of coffee: {coffee.cost()}\")  # Output: Cost of coffee: 2",
        "detail": "design_patterns.decorator.decorator",
        "documentation": {}
    },
    {
        "label": "Coffee",
        "kind": 6,
        "importPath": "design_patterns.decorator.decorator",
        "description": "design_patterns.decorator.decorator",
        "peekOfCode": "class Coffee:\n    def cost(self) -> float:\n        return 2\nif __name__ == \"__main__\":\n    coffee = Coffee()\n    print(f\"Cost of coffee: {coffee.cost()}\")  # Output: Cost of coffee: 2\n    milk_coffee = MilkDecorator(coffee)\n    print(\n        f\"Cost of milk coffee: {milk_coffee.cost()}\"\n    )  # Output: Cost of milk coffee: 2.5",
        "detail": "design_patterns.decorator.decorator",
        "documentation": {}
    },
    {
        "label": "Vehicle",
        "kind": 6,
        "importPath": "design_patterns.factory.examples.vehicle_factory",
        "description": "design_patterns.factory.examples.vehicle_factory",
        "peekOfCode": "class Vehicle(ABC):\n    @abstractmethod\n    def drive(self):\n        pass\n# ------------------------------------- - ------------------------------------ #\nclass Car(Vehicle):\n    def drive(self):\n        return \"Driving a car\"\nclass Motorcycle(Vehicle):\n    def drive(self):",
        "detail": "design_patterns.factory.examples.vehicle_factory",
        "documentation": {}
    },
    {
        "label": "Car",
        "kind": 6,
        "importPath": "design_patterns.factory.examples.vehicle_factory",
        "description": "design_patterns.factory.examples.vehicle_factory",
        "peekOfCode": "class Car(Vehicle):\n    def drive(self):\n        return \"Driving a car\"\nclass Motorcycle(Vehicle):\n    def drive(self):\n        return \"Riding a motorcycle\"\nclass Truck(Vehicle):\n    def drive(self):\n        return \"Driving a truck\"\n# ------------------------------------- - ------------------------------------ #",
        "detail": "design_patterns.factory.examples.vehicle_factory",
        "documentation": {}
    },
    {
        "label": "Motorcycle",
        "kind": 6,
        "importPath": "design_patterns.factory.examples.vehicle_factory",
        "description": "design_patterns.factory.examples.vehicle_factory",
        "peekOfCode": "class Motorcycle(Vehicle):\n    def drive(self):\n        return \"Riding a motorcycle\"\nclass Truck(Vehicle):\n    def drive(self):\n        return \"Driving a truck\"\n# ------------------------------------- - ------------------------------------ #\nclass VehicleFactory(Factory):\n    def create(self, vehicle_type: str) -> Optional[Vehicle]:\n        if vehicle_type == \"car\":",
        "detail": "design_patterns.factory.examples.vehicle_factory",
        "documentation": {}
    },
    {
        "label": "Truck",
        "kind": 6,
        "importPath": "design_patterns.factory.examples.vehicle_factory",
        "description": "design_patterns.factory.examples.vehicle_factory",
        "peekOfCode": "class Truck(Vehicle):\n    def drive(self):\n        return \"Driving a truck\"\n# ------------------------------------- - ------------------------------------ #\nclass VehicleFactory(Factory):\n    def create(self, vehicle_type: str) -> Optional[Vehicle]:\n        if vehicle_type == \"car\":\n            return Car()\n        if vehicle_type == \"motorcycle\":\n            return Motorcycle()",
        "detail": "design_patterns.factory.examples.vehicle_factory",
        "documentation": {}
    },
    {
        "label": "VehicleFactory",
        "kind": 6,
        "importPath": "design_patterns.factory.examples.vehicle_factory",
        "description": "design_patterns.factory.examples.vehicle_factory",
        "peekOfCode": "class VehicleFactory(Factory):\n    def create(self, vehicle_type: str) -> Optional[Vehicle]:\n        if vehicle_type == \"car\":\n            return Car()\n        if vehicle_type == \"motorcycle\":\n            return Motorcycle()\n        if vehicle_type == \"truck\":\n            return Truck()\n        else:\n            print(f\"Unknown vehicle type: {vehicle_type}\")",
        "detail": "design_patterns.factory.examples.vehicle_factory",
        "documentation": {}
    },
    {
        "label": "Factory",
        "kind": 6,
        "importPath": "design_patterns.factory.factory",
        "description": "design_patterns.factory.factory",
        "peekOfCode": "class Factory(ABC):\n    @abstractmethod\n    def create(self):\n        pass",
        "detail": "design_patterns.factory.factory",
        "documentation": {}
    },
    {
        "label": "Person",
        "kind": 6,
        "importPath": "design_patterns.observer.examples.weather_station",
        "description": "design_patterns.observer.examples.weather_station",
        "peekOfCode": "class Person(Subscriber):\n    def __init__(self, name: str):\n        self.name = name\n    def receive_notification(self, message):\n        print(f\"{self.name} received a notification: {message}\")\n# ------------------------------------- - ------------------------------------ #\nclass WeatherStation(Publisher):\n    def __init__(self):\n        self.subscribers = []\n    def add_subscriber(self, subscriber: Subscriber):",
        "detail": "design_patterns.observer.examples.weather_station",
        "documentation": {}
    },
    {
        "label": "WeatherStation",
        "kind": 6,
        "importPath": "design_patterns.observer.examples.weather_station",
        "description": "design_patterns.observer.examples.weather_station",
        "peekOfCode": "class WeatherStation(Publisher):\n    def __init__(self):\n        self.subscribers = []\n    def add_subscriber(self, subscriber: Subscriber):\n        self.subscribers.append(subscriber)\n    def remove_subscriber(self, subscriber: Subscriber):\n        self.subscribers.remove(subscriber)\n    def notify_subscribers(self):\n        for subscriber in self.subscribers:\n            subscriber.receive_notification(\"Weather is sunny today\")",
        "detail": "design_patterns.observer.examples.weather_station",
        "documentation": {}
    },
    {
        "label": "Subscriber",
        "kind": 6,
        "importPath": "design_patterns.observer.observer",
        "description": "design_patterns.observer.observer",
        "peekOfCode": "class Subscriber(ABC):\n    @abstractmethod\n    def receive_notification(self, message: str):\n        pass\nclass Publisher(ABC):\n    @abstractmethod\n    def add_subscriber(self, subscriber: Subscriber):\n        pass\n    @abstractmethod\n    def remove_subscriber(self, subscriber: Subscriber):",
        "detail": "design_patterns.observer.observer",
        "documentation": {}
    },
    {
        "label": "Publisher",
        "kind": 6,
        "importPath": "design_patterns.observer.observer",
        "description": "design_patterns.observer.observer",
        "peekOfCode": "class Publisher(ABC):\n    @abstractmethod\n    def add_subscriber(self, subscriber: Subscriber):\n        pass\n    @abstractmethod\n    def remove_subscriber(self, subscriber: Subscriber):\n        pass\n    @abstractmethod\n    def notify_subscribers(self):\n        pass",
        "detail": "design_patterns.observer.observer",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": "design_patterns.singleton.examples.logger",
        "description": "design_patterns.singleton.examples.logger",
        "peekOfCode": "class Logger(Singleton):\n    def __init__(self):\n        if not hasattr(self, \"logs\"):\n            self.logs = []\n    def log(self, message):\n        self.logs.append(message)\n    def show_logs(self):\n        for log in self.logs:\n            print(log)\nif __name__ == \"__main__\":",
        "detail": "design_patterns.singleton.examples.logger",
        "documentation": {}
    },
    {
        "label": "Singleton",
        "kind": 6,
        "importPath": "design_patterns.singleton.singleton",
        "description": "design_patterns.singleton.singleton",
        "peekOfCode": "class Singleton(ABC):\n    _instance = None\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n        return cls._instance",
        "detail": "design_patterns.singleton.singleton",
        "documentation": {}
    },
    {
        "label": "SwordAttack",
        "kind": 6,
        "importPath": "design_patterns.strategy.examples.attack_strategy",
        "description": "design_patterns.strategy.examples.attack_strategy",
        "peekOfCode": "class SwordAttack(Strategy):\n    def execute(self):\n        print(\"Attacking with a sword\")\nclass BowAndArrowAttack(Strategy):\n    def execute(self):\n        print(\"Attacking with a bow and arrow\")\nclass MagicAttack(Strategy):\n    def execute(self):\n        print(\"Attacking with magic\")\n# ------------------------------------- x ------------------------------------ #",
        "detail": "design_patterns.strategy.examples.attack_strategy",
        "documentation": {}
    },
    {
        "label": "BowAndArrowAttack",
        "kind": 6,
        "importPath": "design_patterns.strategy.examples.attack_strategy",
        "description": "design_patterns.strategy.examples.attack_strategy",
        "peekOfCode": "class BowAndArrowAttack(Strategy):\n    def execute(self):\n        print(\"Attacking with a bow and arrow\")\nclass MagicAttack(Strategy):\n    def execute(self):\n        print(\"Attacking with magic\")\n# ------------------------------------- x ------------------------------------ #\nclass Character:\n    def __init__(self, attack_strategy: Strategy):\n        self._attack_strategy = attack_strategy",
        "detail": "design_patterns.strategy.examples.attack_strategy",
        "documentation": {}
    },
    {
        "label": "MagicAttack",
        "kind": 6,
        "importPath": "design_patterns.strategy.examples.attack_strategy",
        "description": "design_patterns.strategy.examples.attack_strategy",
        "peekOfCode": "class MagicAttack(Strategy):\n    def execute(self):\n        print(\"Attacking with magic\")\n# ------------------------------------- x ------------------------------------ #\nclass Character:\n    def __init__(self, attack_strategy: Strategy):\n        self._attack_strategy = attack_strategy\n    @property\n    def attack_strategy(self):\n        return self._attack_strategy",
        "detail": "design_patterns.strategy.examples.attack_strategy",
        "documentation": {}
    },
    {
        "label": "Character",
        "kind": 6,
        "importPath": "design_patterns.strategy.examples.attack_strategy",
        "description": "design_patterns.strategy.examples.attack_strategy",
        "peekOfCode": "class Character:\n    def __init__(self, attack_strategy: Strategy):\n        self._attack_strategy = attack_strategy\n    @property\n    def attack_strategy(self):\n        return self._attack_strategy\n    @attack_strategy.setter\n    def attack_strategy(self, attack_strategy):\n        self._attack_strategy = attack_strategy\n    def attack(self):",
        "detail": "design_patterns.strategy.examples.attack_strategy",
        "documentation": {}
    },
    {
        "label": "Strategy",
        "kind": 6,
        "importPath": "design_patterns.strategy.strategy",
        "description": "design_patterns.strategy.strategy",
        "peekOfCode": "class Strategy(ABC):\n    @abstractmethod\n    def execute(self):\n        pass",
        "detail": "design_patterns.strategy.strategy",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n        like file_created to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location):\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(f'Path \"{location}\" does not exist!')\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python pywin32_postinstall.py -install",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python pywin32_postinstall.py -install\n    If you installed pywin32 via a .exe installer, this should be run\n    automatically after installation, but if it fails you can run it again.\n    If you installed pywin32 via PIP, you almost certainly need to run this to\n    setup the environment correctly.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(os.path.join(tempfile.gettempdir(), \"pywin32_postinstall.log\"), \"w\")\nclass Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to PythonXX\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to PythonXX\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.\n    file_created  # type: ignore[used-before-def]\n    # 3.10 stopped supporting bdist_wininst, but we can still build them with 3.9.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_postinstall",
        "description": "venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ntry:\n    # When this script is run from inside the bdist_wininst installer,\n    # file_created() and directory_created() are additional builtin\n    # functions which write lines to PythonXX\\pywin32-install.log. This is\n    # a list of actions for the uninstaller, the format is inspired by what\n    # the Wise installer also creates.\n    file_created  # type: ignore[used-before-def]\n    # 3.10 stopped supporting bdist_wininst, but we can still build them with 3.9.\n    # This can be kept until Python 3.9 or exe installers support is dropped.",
        "detail": "venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [this_dir] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "this_dir",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "this_dir = os.path.dirname(__file__)\nsite_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [\n    site.getusersitepackages(),\n] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": "venv.Scripts.pywin32_testall",
        "description": "venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": "venv.Scripts.pywin32_testall",
        "documentation": {}
    }
]